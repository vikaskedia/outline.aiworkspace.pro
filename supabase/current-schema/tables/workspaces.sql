CREATE TABLE workspaces (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title character varying NOT NULL,
    description text NULL,
    updated_at timestamp with time zone DEFAULT now() NOT NULL,
    deleted boolean DEFAULT false NOT NULL,
    deleted_by uuid REFERENCES auth.users(id) NULL,
    deleted_at timestamp with time zone NULL,
    created_by uuid REFERENCES auth.users(id) NOT NULL,
    created_at timestamp with time zone DEFAULT now() NOT NULL,
    git_repo character varying NOT NULL,
    email_storage character varying NOT NULL,
    CONSTRAINT delete_consistency CHECK (
        (deleted = false AND deleted_by IS NULL AND deleted_at IS NULL) OR
        (deleted = true AND deleted_by IS NOT NULL AND deleted_at IS NOT NULL)
    )
);

COMMENT ON TABLE workspaces IS 'Workspaces can be soft deleted but not permanently deleted. 
Soft delete requires both deleted_by and deleted_at to be set.

Each workspace has:
1. A name and description which can be edited by anyone with edit rights.
2. An associated email address for communication. 
-- so attorneys can send email to 19fl002753@associateattorney.ai and that email will be associated with the workspace.
3. Goals (see goals.sql)
4. Tasks (see tasks.sql)
5. Events (see events.sql)
6. Files stored in gitea repository

The user who created the workspace is:
1A. Automatically given edit rights
1B. Can later give up his edit rights
1C. Not treated special than anyone else who has edit rights to the workspace';

-- Add comments for the new columns
COMMENT ON COLUMN workspaces.git_repo IS 'Repository name in Gitea where all files for this workspace are stored. Files are managed through the Gitea server as described in FilesCt.vue';

COMMENT ON COLUMN workspaces.email_storage IS 'Email address where communications for this workspace are stored. Emails sent to catchall@associateattorney.ai are processed and stored if they match this workspace''s address as described in EmailsCt.vue';

-- Automatically add creator toworkspace_access on workspace creation
CREATE OR REPLACE FUNCTION add_creator_access() RETURNS TRIGGER AS $$
DECLARE
    creator_id uuid;
BEGIN
    -- Get the creator_id from the NEW record instead of auth.uid()
    creator_id := NEW.created_by;
    
    INSERT INTOworkspace_access (
        workspace_id, 
        shared_with_user_id, 
        access_type, 
        granted_by_uuid
    )
    VALUES (
        NEW.id, 
        creator_id, 
        'edit', 
        creator_id
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER on_workspace_created
    AFTER INSERT ON workspaces
    FOR EACH ROW
    EXECUTE FUNCTION add_creator_access();

-- Create indexes
CREATE INDEX workspaces_created_by_idx ON workspaces USING btree (created_by);
CREATE INDEX workspaces_deleted_idx ON workspaces USING btree (deleted);
CREATE INDEX workspaces_deleted_by_idx ON workspaces USING btree (deleted_by);

-- Enable Row Level Security
ALTER TABLE workspaces ENABLE ROW LEVEL SECURITY;

-- Create RLS Policies
CREATE POLICY "Users can create workspaces" 
    ON workspaces 
    AS PERMISSIVE
    FOR INSERT 
    TO authenticated 
    WITH CHECK (created_by = auth.uid());

CREATE POLICY "Users can view workspaces" 
    ON workspaces 
    AS PERMISSIVE
    FOR SELECT 
    TO authenticated 
    USING (
        (id IN (
            SELECT workspace_id 
            FROMworkspace_access 
            WHERE shared_with_user_id = auth.uid()
        ))
        OR
        (created_by = auth.uid())
    );

CREATE POLICY "Users can update workspaces" 
    ON workspaces
    AS PERMISSIVE
    FOR UPDATE 
    TO authenticated 
    USING (id IN (
        SELECT workspace_id 
        FROMworkspace_access 
        WHERE shared_with_user_id = auth.uid() 
        AND access_type = 'edit'
    ));

CREATE POLICY "Users can soft delete workspaces" 
    ON workspaces
    AS PERMISSIVE
    FOR UPDATE 
    TO authenticated 
    USING (
        id IN (
            SELECT workspace_id 
            FROMworkspace_access 
            WHERE shared_with_user_id = auth.uid() 
            AND access_type = 'edit'
        )
    )
    WITH CHECK (deleted = true);


CREATE OR REPLACE FUNCTION public.get_all_users()
RETURNS TABLE(id uuid, email text)
LANGUAGE sql
SECURITY DEFINER
SET search_path TO 'public'
AS $function$
  SELECT id, email
  FROM auth.users
  ORDER BY email;
$function$;

-- Rename columns and constraints for archive concept
ALTER TABLE workspaces 
  RENAME COLUMN deleted TO archived;

ALTER TABLE workspaces 
  RENAME COLUMN deleted_by TO archived_by;

ALTER TABLE workspaces 
  RENAME COLUMN deleted_at TO archived_at;

-- Add new archive_consistency constraint
ALTER TABLE workspaces
  ADD CONSTRAINT archive_consistency CHECK (
    (archived = false AND archived_by IS NULL AND archived_at IS NULL) OR
    (archived = true AND archived_by IS NOT NULL AND archived_at IS NOT NULL)
  );

-- Update existing indexes
DROP INDEX IF EXISTS workspaces_deleted_idx;
DROP INDEX IF EXISTS workspaces_deleted_by_idx;
DROP INDEX IF EXISTS workspaces_archived_idx;
DROP INDEX IF EXISTS workspaces_archived_by_idx;

CREATE INDEX workspaces_archived_idx ON workspaces USING btree (archived);
CREATE INDEX workspaces_archived_by_idx ON workspaces USING btree (archived_by);